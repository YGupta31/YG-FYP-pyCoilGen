import numpy as np

def stream_function_optimization(coil_parts, target_field, input):
    """
    Performs stream function optimization on coil parts.

    Args:
        coil_parts (list): List of coil parts.
        target_field: Target field.
        input: Input parameters.

    Returns:
        coil_parts (list): Updated coil parts.
        combined_mesh: Combined mesh.
        b_field_opt_sf: Magnetic field generated by optimized stream function.
    """

    tikonov_reg_factor = input.tikonov_reg_factor

    # Combine the matrices from the different mesh parts
    sensitivity_matrix = []
    gradient_sensitivity_matrix = []
    resistance_matrix = []
    current_density_mat = []

    for part_ind in range(len(coil_parts)):
        if part_ind == 0:
            current_density_mat = coil_parts[part_ind].current_density_mat
        else:
            current_density_mat = np.concatenate(
                [
                    np.block(
                        [
                            current_density_mat[:, :, 0],
                            coil_parts[part_ind].current_density_mat[:, :, 0],
                        ]
                    ),
                    np.block(
                        [
                            current_density_mat[:, :, 1],
                            coil_parts[part_ind].current_density_mat[:, :, 1],
                        ]
                    ),
                    np.block(
                        [
                            current_density_mat[:, :, 2],
                            coil_parts[part_ind].current_density_mat[:, :, 2],
                        ]
                    ),
                ],
                axis=2,
            )

        sensitivity_matrix.append(coil_parts[part_ind].sensitivity_matrix)
        gradient_sensitivity_matrix.append(coil_parts[part_ind].sensitivity_matrix)
        resistance_matrix = np.block(
            [
                [resistance_matrix],
                [coil_parts[part_ind].resistance_matrix],
            ]
        )

    # Generate a combined mesh container
    combined_mesh = coil_parts[0].coil_mesh
    combined_mesh.mesh_part_vertex_ind = np.ones(
        (1, combined_mesh.vertices.shape[1])
    )

    for part_ind in range(1, len(coil_parts)):
        combined_mesh.faces = np.concatenate(
            [combined_mesh.faces, coil_parts[part_ind].coil_mesh.faces + combined_mesh.vertices.shape[1]], axis=1
        )
        combined_mesh.n = np.concatenate(
            [combined_mesh.n, coil_parts[part_ind].coil_mesh.n], axis=1
        )
        combined_mesh.uv = np.concatenate(
            [combined_mesh.uv, coil_parts[part_ind].coil_mesh.uv], axis=1
        )
        combined_mesh.mesh_part_vertex_ind = np.concatenate(
            [
                combined_mesh.mesh_part_vertex_ind,
                np.ones(
                    (1, coil_parts[part_ind].coil_mesh.vertices.shape[1])
                ) * part_ind,
            ],
            axis=1,
        )

        for boundary_ind in range(len(coil_parts[part_ind].coil_mesh.boundary)):
            combined_mesh.boundary.append(
                coil_parts[part_ind].coil_mesh.boundary[boundary_ind]
                + combined_mesh.vertices.shape[1]
            )

        combined_mesh.vertices = np.concatenate(
            [combined_mesh.vertices, coil_parts[part_ind].coil_mesh.vertices], axis=1
        )

    combined_mesh.bounding_box = np.array(
        [
            [np.min(combined_mesh.vertices[0, :]), np.max(combined_mesh.vertices[0, :])],
            [np.min(combined_mesh.vertices[1, :]), np.max(combined_mesh.vertices[1, :])],
            [np.min(combined_mesh.vertices[2, :]), np.max(combined_mesh.vertices[2, :])],
        ]
    )
    set_zero_flag = False  # Flag to force the potential on the boundary nodes to zero

    # Reduce target field only to z component
    sensitivity_matrix_single = sensitivity_matrix[2]
    target_field_single = target_field.b[2]

    # Reduce the Resistance matrix for boundary nodes
    reduced_res_matrix, _, _ = reduce_matrices_for_boundary_nodes(
        resistance_matrix, combined_mesh, set_zero_flag
    )

    # Reduce the sensitivity matrix for boundary nodes
    reduced_sensitivity_matrix, boundary_nodes, is_not_boundary_node = reduce_matrices_for_boundary_nodes(
        sensitivity_matrix_single, combined_mesh, set_zero_flag
    )

    reduced_gradient_sensitivity_matrix_x, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[0], combined_mesh, set_zero_flag
    )
    reduced_gradient_sensitivity_matrix_y, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[1], combined_mesh, set_zero_flag
    )
    reduced_gradient_sensitivity_matrix_z, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[2], combined_mesh, set_zero_flag
    )

    # Reduce the current density matrix for boundary nodes
    red_current_density_mat_u, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 0].T, combined_mesh, set_zero_flag
    )
    red_current_density_mat_v, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 1].T, combined_mesh, set_zero_flag
    )
    red_current_density_mat_w, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 2].T, combined_mesh, set_zero_flag
    )

    # Scale the tikonov regularization factor with the number of target points and mesh vertices
    tikonov_reg_factor = tikonov_reg_factor * (
        reduced_sensitivity_matrix.shape[0] / reduced_sensitivity_matrix.shape[1]
    )

    if input.sf_opt_method == "tikkonov":
        # Calculate the stream function by the tikonov optimization approach
        tik_reg_mat = tikonov_reg_factor * reduced_res_matrix
        reduced_sf = np.linalg.pinv(
            reduced_sensitivity_matrix.T
            @ reduced_sensitivity_matrix
            + tik_reg_mat.T
            @ tik_reg_mat
        ) @ reduced_sensitivity_matrix.T @ target_field_single
    else:
        # For initialization, calculate the tikkonov solution; then do an iterative optimization
        tik_reg_mat = tikonov_reg_factor * reduced_res_matrix
        reduced_sf = np.linalg.pinv(
            reduced_sensitivity_matrix.T
            @ reduced_sensitivity_matrix
            + tik_reg_mat.T
            @ tik_reg_mat
        ) @ reduced_sensitivity_matrix.T @ target_field_single

        # Find the constrained solution
        stream_func_max = np.max(reduced_sf) * 2
        lb = np.ones_like(reduced_sf) * (-1) * stream_func_max
        ub = np.ones_like(reduced_sf) * stream_func_max

        def cost_function(x):
            return np.sum(
                (reduced_sensitivity_matrix @ x - target_field_single) ** 2
            ) + tikonov_reg_factor * (x.T @ reduced_res_matrix @ x)

        options = {"disp": True, "algorithm": "sqp"}
        options["MaxIterations"] = input.fmincon_parameter[0]
        options["MaxFunctionEvaluations"] = input.fmincon_parameter[1]
        options["OptimalityTolerance"] = input.fmincon_parameter[2]
        options["ConstraintTolerance"] = input.fmincon_parameter[3]
        options["StepTolerance"] = input.fmincon_parameter[4]
        reduced_sf = fmincon(
            cost_function,
            reduced_sf,
            [],
            [],
            [],
            [],
            lb,
            ub,
            [],
            options=options,
        )

    # Reexpand the stream potential to the boundary nodes
    opt_stream_func = reexpand_stream_function_for_boundary_nodes(
        reduced_sf, boundary_nodes, is_not_boundary_node, set_zero_flag
    )
    combined_mesh.stream_function = opt_stream_func

    # Calculate the magnetic field generated by the optimized stream function
    b_field_opt_sf = np.concatenate(
        [
            sensitivity_matrix[0] @ opt_stream_func,
            sensitivity_matrix[1] @ opt_stream_func,
            sensitivity_matrix[2] @ opt_stream_func,
        ],
        axis=1,
    )

    # Separate the optimized stream function again onto the different mesh parts
    for part_ind in range(len(coil_parts)):
        coil_parts[part_ind].stream_function = opt_stream_func[
            combined_mesh.mesh_part_vertex_ind == (part_ind + 1)
        ]
        jx = coil_parts[part_ind].stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 0]
        jy = coil_parts[part_ind].stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 1]
        jz = coil_parts[part_ind].stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 2]

        coil_parts[part_ind].current_density = np.concatenate(
            [jx, jy, jz], axis=1
        )

    return coil_parts, combined_mesh, b_field_opt_sf

def reduce_matrices_for_boundary_nodes(full_mat, coil_mesh, set_zero_flag):
    """
    Reduce the sensitivity matrix in order to limit the degrees of freedom on
    the boundary nodes and make sure that they have constant sf later for each boundary.

    Args:
        full_mat: Full matrix to be reduced.
        coil_mesh: Coil mesh.
        set_zero_flag: Flag to force the potential on the boundary nodes to zero.

    Returns:
        reduced_mat: Reduced matrix.
        boundary_nodes: Boundary nodes.
        is_not_boundary_node: Non-boundary nodes.
    """

    num_nodes = coil_mesh.vertices.shape[1]
    dim_to_reduce = full_mat.shape == (num_nodes, num_nodes)
    num_boundaries = len(coil_mesh.boundary)
    num_nodes_per_boundary = np.array(
        [len(np.unique(coil_mesh.boundary[x])) for x in range(num_boundaries)]
    )

    is_not_boundary_node = np.setdiff1d(
        np.arange(full_mat.shape[1]), np.concatenate(coil_mesh.boundary)
    )
    boundary_nodes = [
        np.unique(coil_mesh.boundary[x]) for x in range(num_boundaries)
    ]
    reduced_mat = full_mat.copy()

    if np.sum(dim_to_reduce == 1) != 0:
        for dim_to_reduce_ind in np.where(dim_to_reduce)[0]:
            for boundary_ind in range(num_boundaries):
                if set_zero_flag:
                    reduced_mat[boundary_nodes[boundary_ind], :] = 0
                else:
                    reduced_mat[boundary_nodes[boundary_ind][0], :] = np.sum(
                        reduced_mat[boundary_nodes[boundary_ind][:], :], axis=dim_to_reduce_ind
                    )

            boundary_nodes_first_inds = [
                boundary_nodes[x][0] for x in range(num_boundaries)
            ]

            for dim_to_reduce_ind in np.where(dim_to_reduce)[0]:
                prev_reduced_mat = reduced_mat.copy()
                reduced_mat[:num_boundaries, dim_to_reduce_ind] = prev_reduced_mat[
                    boundary_nodes_first_inds, dim_to_reduce_ind
                ]
                reduced_mat[num_boundaries:, dim_to_reduce_ind] = prev_reduced_mat[
                    is_not_boundary_node, dim_to_reduce_ind
                ]
                reduced_mat = np.delete(reduced_mat, is_not_boundary_node, axis=0)

    return reduced_mat, boundary_nodes, is_not_boundary_node

def reexpand_stream_function_for_boundary_nodes(
    reduced_sf, boundary_nodes, is_not_boundary_node, set_zero_flag
):
    """
    Reexpand the stream function to all nodes including the boundary nodes.

    Args:
        reduced_sf: Reduced stream function.
        boundary_nodes: Boundary nodes.
        is_not_boundary_node: Non-boundary nodes.
        set_zero_flag: Flag to force the potential on the boundary nodes to zero.

    Returns:
        sf: Expanded stream function.
    """

    sf = np.zeros(
        (len(is_not_boundary_node) + sum(len(boundary_nodes[x]) for x in range(len(boundary_nodes)))), 1
    )

    for boundary_ind in range(len(boundary_nodes)):
        if set_zero_flag:
            sf[boundary_nodes[boundary_ind]] = 0
        else:
            sf[boundary_nodes[boundary_ind]] = reduced_sf[boundary_ind]

    sf[is_not_boundary_node] = reduced_sf[len(boundary_nodes):]

    return sf
